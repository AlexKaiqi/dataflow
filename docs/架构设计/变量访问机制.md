# 变量访问机制

## 核心原则

**变量池在 Pipeline Execution 内全局共享**

- 每个 `PipelineExecution` 拥有独立的变量空间
- 同一执行实例内的所有节点共享这个变量空间
- 变量访问的唯一限制是：**变量必须已存在**

---

## 变量命名空间

### 命名规则

```
pipeline.input.{param_name}     # 流水线输入参数
{node_id}.{output_name}         # 节点输出变量
system.{system_var}             # 系统变量
```

### 示例

```
execution_12345:                        # 执行实例
  ├─ pipeline.input.start_date          # 全局可访问
  ├─ pipeline.input.end_date            # 全局可访问
  ├─ system.execution_id                # 全局可访问
  ├─ system.started_at                  # 全局可访问
  ├─ extract_data.output_path           # extract_data 完成后可访问
  ├─ extract_data.row_count             # extract_data 完成后可访问
  ├─ transform_data.result_path         # transform_data 完成后可访问
  └─ transform_data.processed_count     # transform_data 完成后可访问
```

---

## 可见性规则

### 规则 1: 全局变量

**始终可访问**（执行开始时就存在）

| 变量类型 | 命名空间 | 何时可用 |
|---------|---------|---------|
| 流水线输入 | `pipeline.input.*` | 执行开始时 |
| 系统变量 | `system.*` | 执行开始时 |

### 规则 2: 节点输出变量

**节点完成后可访问**

- 节点执行完成 → 输出变量写入变量池
- 此后任何节点都可以访问这些变量
- 与节点之间的拓扑关系无关

**关键点**：

- ✅ 任何节点都可以引用**已完成节点**的输出
- ❌ 不能引用**尚未执行**或**正在执行**的节点输出

### 规则 3: 访问限制

| 场景 | 是否允许 | 说明 |
|------|---------|------|
| 访问 `pipeline.input.*` | ✅ | 始终可用 |
| 访问 `system.*` | ✅ | 始终可用 |
| 访问已完成节点的输出 | ✅ | 变量已写入变量池 |
| 访问未执行节点的输出 | ❌ | 变量不存在 → 抛出错误 |
| 访问其他执行实例的变量 | ❌ | 执行实例隔离 |
| 子流水线访问父变量 | ❌ | 独立变量空间 |

---

## 执行示例

### 场景：数据处理流水线

```yaml
PipelineDefinition:
  inputVariables:
    - start_date
    - end_date
  
  nodes:
    # 节点 A
    - id: extract_data
      startWhen: "event:pipeline.started"
      inputBindings:
        start: "{{ pipeline.input.start_date }}"  # ✅ 可访问
        end: "{{ pipeline.input.end_date }}"      # ✅ 可访问
      # 输出: extract_data.output_path, extract_data.row_count
    
    # 节点 B
    - id: transform_data
      startWhen: "event:extract_data.completed"
      inputBindings:
        input: "{{ extract_data.output_path }}"   # ✅ 可访问（A 已完成）
        count: "{{ extract_data.row_count }}"     # ✅ 可访问（A 已完成）
      # 输出: transform_data.result_path
    
    # 节点 C
    - id: validate_result
      startWhen: "event:transform_data.completed"
      inputBindings:
        data: "{{ transform_data.result_path }}"  # ✅ 可访问（B 已完成）
        original_count: "{{ extract_data.row_count }}"  # ✅ 可访问（A 已完成）
```

### 执行过程中的变量池状态

**1. 执行开始**

```
变量池状态:
  pipeline.input.start_date: "2025-01-01"
  pipeline.input.end_date: "2025-01-31"
  system.execution_id: "exec_12345"
  system.started_at: "2025-01-15T10:00:00Z"
```

**2. extract_data 完成后**

```
变量池状态:
  pipeline.input.start_date: "2025-01-01"
  pipeline.input.end_date: "2025-01-31"
  system.execution_id: "exec_12345"
  system.started_at: "2025-01-15T10:00:00Z"
  extract_data.output_path: "s3://bucket/extracted.parquet"  ← 新增
  extract_data.row_count: 1000000  ← 新增

此时任何节点都可以访问 extract_data.* 的变量
```

**3. transform_data 完成后**

```
变量池状态:
  pipeline.input.start_date: "2025-01-01"
  pipeline.input.end_date: "2025-01-31"
  system.execution_id: "exec_12345"
  system.started_at: "2025-01-15T10:00:00Z"
  extract_data.output_path: "s3://bucket/extracted.parquet"
  extract_data.row_count: 1000000
  transform_data.result_path: "s3://bucket/transformed.parquet"  ← 新增

此时任何节点都可以访问 transform_data.* 的变量
```

---

## 错误场景

### 场景 1: 访问不存在的变量

```yaml
节点配置:
  - id: node_a
    startWhen: "event:pipeline.started"
    inputBindings:
      data: "{{ node_b.output }}"  # ❌ node_b 尚未执行
```

**错误信息**：

```
ErrorCode: VARIABLE_NOT_FOUND
Message: "Variable 'node_b.output' not found in execution exec_12345"
Suggestion: "Ensure node 'node_b' has completed before referencing its outputs"
```

### 场景 2: 访问其他执行实例的变量

```yaml
节点配置:
  - id: node_a
    inputBindings:
      # 尝试访问另一个执行实例的变量
      data: "{{ execution_67890.node_x.output }}"  # ❌ 跨执行实例访问
```

**错误信息**：

```
ErrorCode: INVALID_VARIABLE_NAME
Message: "Invalid variable name: execution_67890.node_x.output"
Suggestion: "Variables are scoped to the current execution instance"
```

---

## 与事件驱动的关系

### 事件决定执行顺序，不是变量依赖

**重要区别**：

| 机制 | 作用 | 示例 |
|------|------|------|
| **事件表达式** (startWhen) | 决定节点何时执行 | `startWhen: "event:node_a.completed"` |
| **变量引用** (inputBindings) | 获取节点的输入数据 | `data: "{{ node_a.output }}"` |

**执行流程**：

```
1. 编排引擎监听事件
   ↓
2. 当 node_a.completed 事件发生
   ↓
3. 触发 node_b (startWhen 满足)
   ↓
4. 解析 node_b 的 inputBindings
   ↓
5. 从变量池获取 node_a.output
   ↓
6. 启动 node_b 执行
```

**关键点**：

- **事件**控制"何时执行"（控制流）
- **变量**传递"执行什么"（数据流）
- 二者是独立的机制，但通常配合使用

---

## 子流水线的变量隔离

### 独立变量空间

**父流水线** 和 **子流水线** 拥有完全独立的变量空间：

```
父流水线 (execution_parent):
  pipeline.input.batch_date: "2025-01-01"
  prepare_data.input_path: "s3://input.csv"
  
  └─ 子流水线节点: sub_processing
      └─ 子流水线执行 (execution_child):
          pipeline.input.input_file: "s3://input.csv"  # 独立空间
          transform.temp_path: "s3://temp.csv"         # 独立空间
          
          ❌ 不能访问 prepare_data.input_path (父流水线变量)
```

### 数据传递机制

**输入传递**：通过 `inputBindings`

```yaml
父流水线:
  - id: sub_processing
    type: pipeline
    inputBindings:
      # 父流水线变量 → 子流水线输入
      input_file: "{{ prepare_data.input_path }}"
      batch_size: 1000
```

**输出传递**：通过 `outputVariables`

```yaml
子流水线完成后:
  父流水线变量池写入:
    sub_processing.output_path: "s3://result.csv"
    sub_processing.record_count: 5000
```

---

## 实现方式

### 变量池接口

```
变量池操作:
  - set(execution_id, variable_name, value)
  - get(execution_id, variable_name) → value
  - exists(execution_id, variable_name) → boolean
  - resolve_expression(execution_id, expression) → value
```

### 访问检查

**运行时检查**（主要方式）：

```
解析 inputBindings 时:
  1. 提取表达式中的变量引用
  2. 查询变量池: exists(execution_id, variable_name)
  3. 如果不存在 → 抛出 VARIABLE_NOT_FOUND 错误
  4. 如果存在 → 获取变量值
```

**静态分析**（可选辅助）：

```
流水线启动前:
  1. 提取所有 inputBindings 中的变量引用
  2. 检查变量名是否符合命名规范
  3. 标记可能的拼写错误
  4. 提供警告信息（不阻止执行）
```

---

## 设计优势

### 1. 简单直观

- 变量池是全局共享的"数据仓库"
- 不需要理解复杂的拓扑依赖关系
- 规则简单：变量存在就能访问

### 2. 灵活性高

- 节点可以访问任何已完成节点的输出
- 支持灵活的数据传递模式
- 不受固定拓扑结构限制

### 3. 动态执行

- 执行顺序由事件动态决定
- 支持条件分支、多路汇聚
- 适应复杂的业务场景

### 4. 清晰隔离

- 执行实例级隔离：不同执行互不干扰
- 父子流水线隔离：封装性强，可复用

---

## 总结

| 概念 | 说明 |
|------|------|
| **变量空间** | 每个 PipelineExecution 拥有独立的变量池 |
| **可见性** | 执行实例内全局共享，变量存在即可访问 |
| **限制** | 只能访问已存在的变量（运行时检查） |
| **执行顺序** | 由事件表达式决定，不是由变量依赖决定 |
| **子流水线** | 独立变量空间，通过接口传递数据 |

**关键理解**：

1. **不是基于 DAG 拓扑** → 变量可见性不受拓扑限制
2. **是基于变量存在性** → 变量存在就能访问
3. **事件控制执行** → 节点何时执行由 startWhen 决定
4. **变量传递数据** → inputBindings 从变量池获取数据

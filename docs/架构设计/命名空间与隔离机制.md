# 命名空间与隔离机制

## 核心概念

**命名空间是本系统实现隔离的核心机制**

- **事件隔离**：通过 `execution_id` 实现
- **变量隔离**：通过 `execution_id + variable_name` 实现
- **子流水线隔离**：通过独立的 `execution_id` 实现

---

## 1. 事件命名空间

### 1.1 事件标识

**完整事件标识** = `(execution_id, event_type)`

```
示例:
  (exec_12345, "pipeline.started")
  (exec_12345, "extract_data.completed")
  (exec_67890, "pipeline.started")         # 不同执行实例
```

### 1.2 隔离机制

```
执行实例 A (exec_12345):
  └─ 事件空间
      ├─ event: pipeline.started
      ├─ event: extract_data.completed
      └─ event: transform_data.completed

执行实例 B (exec_67890):
  └─ 事件空间（完全独立）
      ├─ event: pipeline.started
      ├─ event: extract_data.completed
      └─ event: transform_data.completed

不同执行实例的事件互不可见
```

### 1.3 查询接口

```
事件管理器接口:
  has_event(execution_id, event_type) → boolean
  get_event(execution_id, event_type) → Event

查询作用域:
  - 始终限定在指定的 execution_id 内
  - 无法跨执行实例查询事件
```

---

## 2. 变量命名空间

### 2.1 变量标识

**完整变量标识** = `(execution_id, variable_name)`

```
变量名格式:
  {namespace}.{name}

命名空间类型:
  - pipeline.input.*     # 流水线输入
  - {node_id}.*          # 节点输出
  - system.*             # 系统变量

示例:
  (exec_12345, "pipeline.input.start_date")
  (exec_12345, "extract_data.output_path")
  (exec_67890, "extract_data.output_path")  # 不同执行实例
```

### 2.2 隔离机制

**第一层：execution_id 隔离**

```
执行实例 A (exec_12345):
  └─ 变量空间
      ├─ pipeline.input.start_date: "2025-01-01"
      ├─ extract_data.output_path: "s3://bucket/data_a.csv"
      └─ extract_data.row_count: 1000000

执行实例 B (exec_67890):
  └─ 变量空间（完全独立）
      ├─ pipeline.input.start_date: "2025-02-01"
      ├─ extract_data.output_path: "s3://bucket/data_b.csv"
      └─ extract_data.row_count: 2000000

同名变量在不同执行实例中互不影响
```

**第二层：命名空间隔离**

```
执行实例内部 (exec_12345):
  ├─ pipeline.input.*        # 命名空间1：流水线输入
  │   ├─ start_date
  │   └─ end_date
  │
  ├─ extract_data.*          # 命名空间2：节点输出
  │   ├─ output_path
  │   └─ row_count
  │
  ├─ transform_data.*        # 命名空间3：节点输出
  │   ├─ result_path
  │   └─ processed_count
  │
  └─ system.*                # 命名空间4：系统变量
      ├─ execution_id
      └─ started_at

命名空间通过变量名前缀隔离，避免命名冲突
```

### 2.3 查询接口

```
变量池接口:
  set(execution_id, variable_name, value)
  get(execution_id, variable_name) → value
  exists(execution_id, variable_name) → boolean

查询作用域:
  - 始终限定在指定的 execution_id 内
  - 无法跨执行实例访问变量
```

---

## 3. 子流水线隔离

### 3.1 独立执行空间

**子流水线通过独立的 execution_id 实现隔离**：

```
父流水线执行:
  execution_id: exec_parent_12345
  
  └─ 子流水线节点: sub_processing
      └─ 子流水线执行:
          execution_id: exec_child_67890  # 独立的 execution_id
          
父子流水线拥有完全独立的执行空间
```

### 3.2 事件隔离

```
父流水线 (exec_parent_12345):
  └─ 事件空间
      ├─ event: pipeline.started
      ├─ event: prepare_data.completed
      └─ event: sub_processing.completed

子流水线 (exec_child_67890):
  └─ 事件空间（独立）
      ├─ event: pipeline.started
      ├─ event: transform.completed
      └─ event: pipeline.completed

子流水线的内部事件对父流水线不可见
```

### 3.3 变量隔离

```
父流水线 (exec_parent_12345):
  └─ 变量空间
      ├─ pipeline.input.batch_date
      ├─ prepare_data.input_path
      └─ sub_processing.output_path      # 子流水线的输出

子流水线 (exec_child_67890):
  └─ 变量空间（独立）
      ├─ pipeline.input.input_file       # 独立输入
      ├─ transform.temp_path             # 内部变量
      └─ pipeline.output.output_path     # 子流水线输出

子流水线的内部变量对父流水线不可见
```

### 3.4 数据传递

**通过接口传递，不破坏隔离**：

```
输入传递:
  父流水线 (exec_parent) 
    → inputBindings: { input_file: "{{ prepare_data.input_path }}" }
    → 编排引擎读取父变量池的值
    → 写入子流水线 (exec_child) 的变量池: pipeline.input.input_file

输出传递:
  子流水线 (exec_child) 执行完成
    → 编排引擎读取子变量池的输出: pipeline.output.output_path
    → 写入父流水线 (exec_parent) 的变量池: sub_processing.output_path

数据复制，不是引用共享
```

---

## 4. 隔离效果

### 4.1 并发执行隔离

**同一流水线的多个并发执行互不干扰**：

```
流水线定义: ETL Pipeline

执行实例1 (exec_001):
  - 处理 2025-01-01 的数据
  - 变量: pipeline.input.date = "2025-01-01"
  - 变量: extract_data.row_count = 1000000

执行实例2 (exec_002):
  - 处理 2025-01-02 的数据
  - 变量: pipeline.input.date = "2025-01-02"
  - 变量: extract_data.row_count = 1500000

两个实例完全独立，互不影响
```

### 4.2 父子流水线隔离

**父子流水线拥有独立的执行空间**：

```
父流水线不能访问:
  ❌ 子流水线的内部事件
  ❌ 子流水线的内部变量
  ✅ 只能访问子流水线的输出（通过 outputVariables）

子流水线不能访问:
  ❌ 父流水线的事件
  ❌ 父流水线的变量
  ✅ 只能访问父流水线传递的输入（通过 inputBindings）
```

### 4.3 测试隔离

**隔离机制支持独立测试**：

```
测试子流水线:
  - 创建独立的 execution_id
  - 初始化测试输入变量
  - 执行子流水线
  - 验证输出变量
  - 不需要模拟父流水线环境

测试父流水线:
  - 可以 Mock 子流水线的输出
  - 不需要真实执行子流水线
```

---

## 5. 实现要点

### 5.1 存储结构

**事件存储**：

```
Key 设计:
  events:{execution_id}:{event_type}

示例:
  events:exec_12345:pipeline.started
  events:exec_12345:extract_data.completed
  events:exec_67890:pipeline.started  # 不同命名空间
```

**变量存储**：

```
Key 设计:
  variables:{execution_id}:{variable_name}

示例:
  variables:exec_12345:pipeline.input.start_date
  variables:exec_12345:extract_data.output_path
  variables:exec_67890:extract_data.output_path  # 不同命名空间
```

### 5.2 查询约束

**强制限定作用域**：

```
所有查询接口都必须提供 execution_id:
  ✅ has_event(execution_id, event_type)
  ✅ get(execution_id, variable_name)
  ❌ has_event(event_type)  # 缺少 execution_id，禁止

不支持跨命名空间查询:
  ❌ 不能查询其他 execution_id 的数据
  ❌ 不能列出所有 execution_id
```

### 5.3 生命周期管理

**自动清理**：

```
流水线执行完成:
  1. 标记执行实例为已完成
  2. 保留一段时间供调试查询
  3. 定期清理过期数据

清理范围:
  - 清理事件: 删除 events:{execution_id}:* 的所有数据
  - 清理变量: 删除 variables:{execution_id}:* 的所有数据
```

---

## 6. 设计优势

### 6.1 清晰的隔离边界

```
隔离维度:
  - 执行实例隔离（execution_id）
  - 命名空间隔离（variable_name 前缀）
  - 父子流水线隔离（独立 execution_id）

隔离效果:
  - 并发执行互不干扰
  - 父子流水线封装清晰
  - 测试环境独立
```

### 6.2 简单的实现

```
核心机制:
  - 所有查询带上 execution_id 前缀
  - 不需要复杂的权限控制
  - 不需要额外的隔离机制

存储简单:
  - Key 包含 execution_id
  - 自然实现隔离
  - 易于清理
```

### 6.3 良好的扩展性

```
支持场景:
  - 并发执行（不同 execution_id）
  - 嵌套流水线（独立 execution_id）
  - 分布式执行（共享存储，execution_id 隔离）
  - 多租户隔离（可扩展 tenant_id）
```

---

## 7. 总结

### 7.1 隔离机制

| 隔离维度 | 实现方式 | 效果 |
|---------|---------|------|
| **执行实例隔离** | execution_id | 不同执行互不影响 |
| **命名空间隔离** | 变量名前缀 | 避免命名冲突 |
| **父子流水线隔离** | 独立 execution_id | 封装性强，可复用 |

### 7.2 关键原则

- **命名空间是隔离的基础**
- **execution_id 是第一层隔离**
- **变量名前缀是第二层隔离**
- **所有查询必须限定作用域**
- **数据传递通过接口，不破坏隔离**

### 7.3 设计理念

```
简单而强大:
  - 不需要复杂的权限系统
  - 不需要额外的隔离机制
  - 只需要在 Key 中包含 execution_id
  - 自然实现多层隔离
```

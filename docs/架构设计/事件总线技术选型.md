# 事件总线技术选型

> **决策日期**: 2025-12-09
> **影响范围**: 事件驱动执行引擎、节点编排、外部系统集成

---

## 需求分析

### 核心需求

基于场景5和事件驱动执行模型（ADR-001），事件总线需要满足以下需求：

#### 1. **事件类型多样性**

| 事件类型 | 特点 | 示例 |
|---------|------|------|
| **节点生命周期事件** | 高频、内部、短暂 | `node_a.completed`, `node_b.failed` |
| **定时事件** | 周期性、外部触发 | `cron:0 2 * * *` |
| **外部系统事件** | 异步、跨系统 | `approval.approved`, `kafka.message_received` |
| **Pipeline 事件** | 全局、系统级 | `pipeline.started`, `pipeline.shutdown` |
| **自定义业务事件** | 任务内部逻辑 | `batch_ready`, `quality_check.threshold_exceeded` |

#### 2. **订阅模式**

- **Once 模式**：事件触发一次后自动取消订阅（批处理任务）
- **Repeat 模式**：持续订阅，每次事件到达都触发（流处理、周期任务）

#### 3. **复杂订阅条件**

```yaml
# AND 汇聚
startWhen: "event:A.completed && event:B.completed && event:C.completed"

# OR 汇聚
startWhen: "event:A.completed || event:B.completed"

# 条件分支
startWhen: "event:A.completed && {{ A.quality_score > 0.9 }}"

# 混合表达式
startWhen: "cron:0 2 * * * && {{ last_run.status == 'success' }}"
```

#### 4. **事件携带数据**

事件需要携带任务输出变量，用于下游节点绑定：

```json
{
  "eventType": "merge_and_validate_features.completed",
  "executionId": "exec_20231209_001",
  "nodeId": "merge_and_validate_features",
  "timestamp": "2023-12-09T12:00:00Z",
  "payload": {
    "merged_features": "hdfs://output/features/20231209",
    "quality_score": 0.85,
    "validation_report": {...}
  }
}
```

#### 5. **性能要求**

| 指标 | 要求 | 说明 |
|------|------|------|
| **吞吐量** | 1000+ events/s | 支持大规模并行任务场景 |
| **延迟** | < 100ms | 节点完成到触发下游的延迟 |
| **可靠性** | At-least-once | 事件不丢失，允许重复 |
| **顺序性** | 同一节点事件有序 | 保证状态变化的逻辑顺序 |

#### 6. **系统集成**

- **内部事件**：Pipeline 内部节点间通信（高频、低延迟）
- **自定义任务事件**：任务执行时通过 SDK 发布事件到事件总线
- **平台事件接口**：外部系统通过 API 发布事件到事件总线
- **多实例部署**：事件总线需支持分布式订阅

---

## 技术选型对比

### 方案1：内存事件总线（Guava EventBus / Spring Event）

#### 技术方案

**Guava EventBus**:
```java
EventBus eventBus = new EventBus();

// 订阅
eventBus.register(new Object() {
    @Subscribe
    public void handleNodeCompleted(NodeCompletedEvent event) {
        // 处理逻辑
    }
});

// 发布
eventBus.post(new NodeCompletedEvent(nodeId, outputs));
```

**Spring ApplicationEvent**:
```java
@Component
public class NodeEventListener {
    @EventListener
    public void handleNodeCompleted(NodeCompletedEvent event) {
        // 处理逻辑
    }
}

// 发布
applicationEventPublisher.publishEvent(new NodeCompletedEvent(...));
```

#### ✅ 优点

1. **简单高效**
   - 纯内存实现，延迟 < 1ms
   - 无需外部依赖
   - 开发调试简单

2. **类型安全**
   - 基于 Java 类型系统
   - 编译期检查
   - IDE 友好

3. **轻量级**
   - 无需额外基础设施
   - 部署简单
   - 资源占用低

4. **集成方便**
   - Spring 原生支持
   - 与 DDD 事件模型契合
   - 支持同步/异步发布

#### ❌ 缺点

1. **单机限制**
   - 事件仅在本地 JVM 内传播
   - 不支持分布式订阅
   - 高可用依赖应用层实现

2. **事件不持久化**
   - 应用重启后事件丢失
   - 无法事件回溯
   - 不支持事件溯源（Event Sourcing）

3. **外部集成困难**
   - 需要额外开发适配器对接外部消息队列
   - 跨语言支持差

4. **功能有限**
   - 无内置过滤、路由能力
   - 订阅管理需自行实现
   - 无消息积压处理

---

### 方案2：消息队列（Kafka / RabbitMQ）

#### 技术方案

**Kafka**:
```java
// 发布
producer.send(new ProducerRecord<>(
    "pipeline-events",
    nodeId,
    eventJson
));

// 订阅
consumer.subscribe(Collections.singletonList("pipeline-events"));
while (true) {
    ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord<String, String> record : records) {
        // 处理事件
    }
}
```

**RabbitMQ**:
```java
// 发布到 Exchange
channel.basicPublish(
    "pipeline-events",  // exchange
    "node.completed",   // routing key
    null,
    eventJson.getBytes()
);

// 订阅 Queue
channel.basicConsume(queueName, true, (consumerTag, delivery) -> {
    String eventJson = new String(delivery.getBody());
    // 处理事件
});
```

#### ✅ 优点

1. **分布式支持**
   - 多实例订阅
   - 高可用、可扩展
   - 支持跨机房部署

2. **持久化**
   - 事件持久化到磁盘
   - 支持事件回溯
   - 应用重启不丢失

3. **高性能**
   - Kafka：百万级 TPS
   - 分区并行消费
   - 异步批量发送

4. **功能丰富**
   - Topic/Queue 隔离
   - 消息过滤、路由
   - 死信队列
   - 消息积压处理

5. **外部集成**
   - 天然支持外部系统集成
   - 标准协议（AMQP、Kafka Protocol）
   - 多语言客户端

#### ❌ 缺点

1. **复杂度高**
   - 需要独立部署 Kafka/RabbitMQ 集群
   - 运维成本高
   - 学习曲线陡峭

2. **延迟较高**
   - 网络开销：10-50ms
   - 不适合低延迟场景

3. **一致性问题**
   - 需要处理消息重复
   - 顺序性需要特殊配置（Kafka 单分区）
   - 事务支持有限

4. **资源消耗**
   - 需要额外的服务器资源
   - 网络带宽占用
   - 存储空间占用

---

### 方案3：Redis Pub/Sub + Stream

#### 技术方案

**Redis Pub/Sub**（适合广播）:
```java
// 发布
redisTemplate.convertAndSend("pipeline-events", eventJson);

// 订阅
redisTemplate.getMessageListenerContainer()
    .addMessageListener(new MessageListenerAdapter(listener),
        new PatternTopic("pipeline-events"));
```

**Redis Stream**（适合持久化队列）:
```java
// 发布
streamOperations.add(StreamRecords.newRecord()
    .ofObject(event)
    .withStreamKey("pipeline-events"));

// 订阅（消费者组）
StreamMessageListenerContainer.create(...)
    .receive(Consumer.from("group", "consumer"),
        StreamOffset.create("pipeline-events", ReadOffset.lastConsumed()),
        message -> {
            // 处理事件
        });
```

#### ✅ 优点

1. **轻量级分布式**
   - 比 Kafka 轻量
   - 比内存总线功能强
   - 部署运维相对简单

2. **双模式支持**
   - Pub/Sub：低延迟广播（< 5ms）
   - Stream：持久化队列
   - 根据场景选择

3. **功能适中**
   - 支持消费者组
   - 消息确认机制
   - 消息 ID 自动生成
   - 支持消息回溯

4. **易于集成**
   - Spring Data Redis 原生支持
   - 多语言客户端
   - 常见的基础设施

#### ❌ 缺点

1. **性能有限**
   - TPS：数万级（低于 Kafka）
   - 不适合超大规模场景
   - 单线程处理

2. **持久化有限**
   - Pub/Sub 不持久化
   - Stream 受内存限制
   - 不适合长期存储

3. **功能简化**
   - 无分区概念
   - 路由能力弱
   - 监控工具少

4. **可靠性**
   - 单点故障（除非 Redis Cluster）
   - 消息可能丢失（Pub/Sub）

---

### 方案4：混合方案（内存 + 外部消息队列）

#### 技术方案

```java
@Component
public class HybridEventBus {
    private final EventBus localEventBus = new EventBus();
    private final KafkaTemplate<String, String> kafkaTemplate;

    // 发布本地事件（高频、内部）
    public void publishLocal(Event event) {
        localEventBus.post(event);
    }

    // 发布全局事件（跨实例、外部）
    public void publishGlobal(Event event) {
        kafkaTemplate.send("pipeline-events", eventJson);
    }

    // 智能路由
    public void publish(Event event) {
        if (isLocalEvent(event)) {
            publishLocal(event);
        } else {
            publishGlobal(event);
        }
    }
}
```

#### 事件分类策略

| 事件类型 | 路由目标 | 原因 |
|---------|---------|------|
| **节点生命周期事件** | 本地（内存） | 高频、低延迟、单实例内传播 |
| **Pipeline 事件** | 全局（Kafka） | 跨实例、系统级 |
| **外部系统事件** | 全局（Kafka） | 需要持久化、跨系统 |
| **定时事件** | 全局（Kafka） | 需要全局协调 |

#### ✅ 优点

1. **兼顾性能与功能**
   - 内部事件低延迟（< 1ms）
   - 外部事件高可靠（Kafka）
   - 按需选择传输方式

2. **渐进式演进**
   - 初期：纯内存实现
   - 中期：引入 Redis
   - 后期：接入 Kafka
   - 降低初始复杂度

3. **成本优化**
   - 高频事件不占用网络/存储
   - 只有必要事件持久化
   - 资源利用率高

4. **灵活性**
   - 根据业务特点调整策略
   - 支持多种外部消息队列
   - 易于扩展

#### ❌ 缺点

1. **架构复杂**
   - 需要维护两套机制
   - 路由逻辑需要精心设计
   - 增加代码复杂度

2. **一致性挑战**
   - 本地事件和全局事件语义不同
   - 跨实例场景需要额外处理
   - 调试困难

3. **运维成本**
   - 需要同时监控两种总线
   - 故障排查复杂

---

## 推荐方案

### 初期方案：内存事件总线（Guava EventBus / Spring Event）

**推荐理由**：

1. **MVP 快速验证**
   - 大部分事件是 Pipeline 内部通信（节点生命周期）
   - 初期单实例部署即可满足需求
   - 降低开发和运维复杂度

2. **符合当前架构**
   - DDD 领域事件模型
   - 单体应用架构
   - 无需外部依赖

3. **性能卓越**
   - 内存延迟 < 1ms
   - 支持 10000+ events/s
   - 满足场景5的需求

4. **易于扩展**
   - 后期可以透明升级到混合方案
   - 事件发布接口抽象化
   - 无需修改业务代码

### 中期演进：内存 + Redis Stream

**触发条件**：
- 需要多实例部署
- 需要外部系统集成（审批、Webhook）
- 需要事件持久化和回溯

**方案**：
```java
public interface EventBus {
    void publish(Event event);
    void subscribe(EventPattern pattern, EventHandler handler);
}

// 本地实现
@Component
@Primary
public class LocalEventBus implements EventBus { ... }

// Redis 实现
@Component
public class RedisEventBus implements EventBus { ... }

// 混合路由
@Component
public class HybridEventBus implements EventBus {
    private final LocalEventBus localBus;
    private final RedisEventBus redisBus;

    @Override
    public void publish(Event event) {
        if (event.scope() == EventScope.LOCAL) {
            localBus.publish(event);
        } else {
            redisBus.publish(event);
        }
    }
}
```

### 长期演进：完整的分布式事件总线

**触发条件**：
- 大规模集群部署（10+ 实例）
- 海量事件（> 100万/天）
- 复杂的外部系统集成
- 需要事件溯源（Event Sourcing）

**方案**：引入 Kafka
- 所有 Pipeline 事件通过 Kafka
- 支持事件回放和审计
- 跨系统事件集成
- 高可用和容错

---

## 实现设计

### 核心抽象

```java
// 事件总线接口
public interface EventBus {
    /**
     * 发布事件
     */
    void publish(DomainEvent event);

    /**
     * 订阅事件
     * @param pattern 事件模式（支持通配符）
     * @param handler 事件处理器
     * @param mode 订阅模式（once/repeat）
     * @return 订阅 ID
     */
    String subscribe(EventPattern pattern, EventHandler handler, SubscriptionMode mode);

    /**
     * 取消订阅
     */
    void unsubscribe(String subscriptionId);
}

// 事件模式（支持复杂匹配）
public interface EventPattern {
    boolean matches(DomainEvent event);

    static EventPattern exact(String eventType) { ... }
    static EventPattern wildcard(String pattern) { ... }  // node_*.completed
    static EventPattern regex(String regex) { ... }
    static EventPattern composite(List<EventPattern> patterns) { ... }  // AND/OR
}

// 事件处理器
@FunctionalInterface
public interface EventHandler {
    void handle(DomainEvent event, EventContext context);
}

// 订阅模式
public enum SubscriptionMode {
    ONCE,    // 触发一次后自动取消
    REPEAT   // 持续订阅
}
```

### Guava EventBus 实现

```java
@Component
public class GuavaEventBusAdapter implements EventBus {
    private final com.google.common.eventbus.EventBus guavaEventBus;
    private final Map<String, EventSubscription> subscriptions;

    public GuavaEventBusAdapter() {
        this.guavaEventBus = new com.google.common.eventbus.EventBus();
        this.subscriptions = new ConcurrentHashMap<>();
    }

    @Override
    public void publish(DomainEvent event) {
        guavaEventBus.post(event);
    }

    @Override
    public String subscribe(EventPattern pattern, EventHandler handler, SubscriptionMode mode) {
        String subscriptionId = UUID.randomUUID().toString();

        Object subscriber = new Object() {
            @Subscribe
            public void onEvent(DomainEvent event) {
                if (pattern.matches(event)) {
                    handler.handle(event, EventContext.current());

                    // Once 模式：触发后自动取消
                    if (mode == SubscriptionMode.ONCE) {
                        unsubscribe(subscriptionId);
                    }
                }
            }
        };

        guavaEventBus.register(subscriber);
        subscriptions.put(subscriptionId, new EventSubscription(subscriber, pattern, mode));

        return subscriptionId;
    }

    @Override
    public void unsubscribe(String subscriptionId) {
        EventSubscription subscription = subscriptions.remove(subscriptionId);
        if (subscription != null) {
            guavaEventBus.unregister(subscription.getSubscriber());
        }
    }
}
```

### Spring Event 实现

```java
@Component
public class SpringEventBusAdapter implements EventBus {
    private final ApplicationEventPublisher eventPublisher;
    private final ApplicationContext applicationContext;
    private final Map<String, GenericApplicationListener> listeners;

    @Override
    public void publish(DomainEvent event) {
        eventPublisher.publishEvent(event);
    }

    @Override
    public String subscribe(EventPattern pattern, EventHandler handler, SubscriptionMode mode) {
        String subscriptionId = UUID.randomUUID().toString();

        GenericApplicationListener listener = new GenericApplicationListener() {
            @Override
            public void onApplicationEvent(ApplicationEvent event) {
                if (event instanceof DomainEvent && pattern.matches((DomainEvent) event)) {
                    handler.handle((DomainEvent) event, EventContext.current());

                    if (mode == SubscriptionMode.ONCE) {
                        unsubscribe(subscriptionId);
                    }
                }
            }

            @Override
            public boolean supportsEventType(ResolvableType eventType) {
                return DomainEvent.class.isAssignableFrom(eventType.getRawClass());
            }
        };

        applicationContext.addApplicationListener(listener);
        listeners.put(subscriptionId, listener);

        return subscriptionId;
    }

    @Override
    public void unsubscribe(String subscriptionId) {
        GenericApplicationListener listener = listeners.remove(subscriptionId);
        if (listener != null) {
            // Spring 5.3+ 支持动态移除
            ((ConfigurableApplicationContext) applicationContext)
                .getApplicationEventMulticaster()
                .removeApplicationListener(listener);
        }
    }
}
```

---

## EventManager 设计

EventManager 负责管理事件订阅和条件评估：

```java
@Component
public class EventManager {
    private final EventBus eventBus;
    private final ExpressionEvaluator expressionEvaluator;
    private final Map<String, List<NodeSubscription>> nodeSubscriptions;

    /**
     * 为 Pipeline 执行注册所有节点的事件订阅
     */
    public void registerPipelineSubscriptions(PipelineExecution execution) {
        for (NodeExecution node : execution.getNodes()) {
            registerNodeSubscriptions(execution, node);
        }
    }

    /**
     * 为单个节点注册事件订阅
     */
    private void registerNodeSubscriptions(PipelineExecution execution, NodeExecution node) {
        Node nodeDef = execution.getDefinition().getNode(node.getNodeId());

        // 注册 startWhen 订阅
        if (nodeDef.getStartWhen() != null) {
            registerStartWhen(execution, node, nodeDef.getStartWhen());
        }

        // 注册 stopWhen 订阅（streaming 任务）
        if (nodeDef.getStopWhen() != null) {
            registerStopWhen(execution, node, nodeDef.getStopWhen());
        }

        // 注册 restartWhen 订阅（streaming 任务）
        if (nodeDef.getRestartWhen() != null) {
            registerRestartWhen(execution, node, nodeDef.getRestartWhen());
        }

        // 注册 alertWhen 订阅
        if (nodeDef.getAlertWhen() != null) {
            registerAlertWhen(execution, node, nodeDef.getAlertWhen());
        }
    }

    /**
     * 注册 startWhen 订阅
     */
    private void registerStartWhen(PipelineExecution execution, NodeExecution node, String expression) {
        // 解析表达式，提取事件模式
        List<EventPattern> patterns = parseEventPatterns(expression);

        // 为每个事件模式注册订阅
        for (EventPattern pattern : patterns) {
            String subscriptionId = eventBus.subscribe(
                pattern,
                event -> handleStartEvent(execution, node, expression, event),
                node.getStartMode()
            );

            // 记录订阅关系
            nodeSubscriptions
                .computeIfAbsent(node.getNodeId(), k -> new ArrayList<>())
                .add(new NodeSubscription(subscriptionId, pattern, expression));
        }
    }

    /**
     * 处理 startWhen 事件
     */
    private void handleStartEvent(PipelineExecution execution, NodeExecution node,
                                   String expression, DomainEvent event) {
        // 评估完整表达式（事件 + 条件）
        Map<String, Object> context = buildEvaluationContext(execution, event);
        boolean shouldStart = expressionEvaluator.evaluate(expression, context);

        if (shouldStart) {
            // 触发节点执行
            execution.startNode(node.getNodeId());
        }
    }

    /**
     * 构建表达式评估上下文
     */
    private Map<String, Object> buildEvaluationContext(PipelineExecution execution, DomainEvent event) {
        Map<String, Object> context = new HashMap<>();

        // Pipeline 输入变量
        context.put("pipeline", Map.of("input", execution.getInputVariables()));

        // 所有节点的输出变量
        for (NodeExecution node : execution.getNodes()) {
            if (node.getOutputs() != null) {
                context.put(node.getNodeId(), node.getOutputs());
            }
        }

        // 当前事件信息
        if (event instanceof NodeEvent) {
            NodeEvent nodeEvent = (NodeEvent) event;
            context.put(nodeEvent.getNodeId(), nodeEvent.getPayload());
        }

        return context;
    }

    /**
     * 解析表达式中的事件模式
     */
    private List<EventPattern> parseEventPatterns(String expression) {
        List<EventPattern> patterns = new ArrayList<>();

        // 正则提取 event:xxx 和 cron:xxx
        Pattern eventPattern = Pattern.compile("event:([\\w.]+)");
        Matcher matcher = eventPattern.matcher(expression);
        while (matcher.find()) {
            patterns.add(EventPattern.exact(matcher.group(1)));
        }

        Pattern cronPattern = Pattern.compile("cron:(.+?)(?:\\s|$|&&|\\|\\|)");
        Matcher cronMatcher = cronPattern.matcher(expression);
        while (cronMatcher.find()) {
            patterns.add(EventPattern.cron(cronMatcher.group(1)));
        }

        return patterns;
    }
}
```

---

## 事件发布接口设计

### 1. 自定义任务发布事件（通过 SDK）

自定义任务开发者在任务执行时，通过 SDK 发布事件到事件总线：

```java
// 任务开发者实现自定义任务
public class CustomDataProcessTask implements Task {
    private final TaskExecutionContext context;

    @Override
    public TaskResult execute(TaskInput input) {
        // 业务逻辑
        processData(input);

        // 发布自定义事件到事件总线
        context.publishEvent("batch_ready", Map.of(
            "batch_id", "batch-001",
            "record_count", 10000,
            "status", "completed"
        ));

        return TaskResult.success();
    }
}
```

**SDK 接口**：

```java
public interface TaskExecutionContext {
    /**
     * 发布自定义事件到事件总线
     * @param eventName 事件名称（相对于节点ID）
     * @param payload 事件载荷
     */
    void publishEvent(String eventName, Map<String, Object> payload);

    /**
     * 获取当前节点ID
     */
    String getNodeId();

    /**
     * 获取执行ID
     */
    String getExecutionId();
}
```

**实现**：

```java
@Component
public class TaskExecutionContextImpl implements TaskExecutionContext {
    private final EventBus eventBus;
    private final String nodeId;
    private final String executionId;

    @Override
    public void publishEvent(String eventName, Map<String, Object> payload) {
        // 构造完整的事件类型：nodeId.eventName
        String eventType = nodeId + "." + eventName;

        CustomNodeEvent event = CustomNodeEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType(eventType)
            .executionId(executionId)
            .nodeId(nodeId)
            .timestamp(Instant.now())
            .payload(payload)
            .build();

        // 发布到事件总线
        eventBus.publish(event);
    }
}
```

**使用示例**：

```yaml
# Pipeline 定义
nodes:
  - id: model_inference_service
    type: task
    taskDefinition:
      ref: "com.company.tasks:custom_inference:1.0.0"
    startWhen: "event:pipeline.started"

  # 订阅自定义任务发布的事件
  - id: store_predictions
    type: task
    taskDefinition:
      ref: "com.company.tasks:sql_load:1.0.0"
    startWhen: "event:model_inference_service.batch_ready"
    startMode: "repeat"
    inputBindings:
      batch_id: "{{ model_inference_service.batch_id }}"
      record_count: "{{ model_inference_service.record_count }}"
```

---

### 2. 外部系统发布事件（通过 REST API）

外部系统（如审批系统、数据源监控系统）通过 REST API 发布事件：

```java
@RestController
@RequestMapping("/api/v1/executions/{executionId}/events")
public class EventPublishController {
    private final EventBus eventBus;
    private final PipelineExecutionRepository executionRepository;

    /**
     * 外部系统发布事件到指定的 Pipeline 执行实例
     */
    @PostMapping
    public ResponseEntity<EventPublishResponse> publishEvent(
            @PathVariable String executionId,
            @RequestBody EventPublishRequest request) {

        // 验证执行实例存在
        PipelineExecution execution = executionRepository.findById(executionId)
            .orElseThrow(() -> new NotFoundException("Execution not found"));

        // 验证权限（可选）
        validatePermission(request.getApiKey(), execution);

        // 创建外部事件
        ExternalEvent event = ExternalEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType(request.getEventType())
            .executionId(executionId)
            .source(request.getSource())
            .timestamp(Instant.now())
            .payload(request.getPayload())
            .build();

        // 发布到事件总线
        eventBus.publish(event);

        return ResponseEntity.ok(new EventPublishResponse(event.getEventId()));
    }
}
```

**请求示例**：

```bash
# 审批系统发布审批完成事件
POST /api/v1/executions/exec_20231209_001/events
Content-Type: application/json
Authorization: Bearer <api-key>

{
  "eventType": "approval.approved",
  "source": "approval-system",
  "payload": {
    "approval_id": "APR-20231209-001",
    "approver": "alice@company.com",
    "result": "approved",
    "comment": "数据质量可接受"
  }
}
```

**Pipeline 订阅示例**：

```yaml
nodes:
  - id: manual_review_features
    type: task
    taskDefinition:
      ref: "com.company.tasks:approval:1.0.0"
    startWhen: "event:merge_and_validate_features.completed && {{ quality_score < 0.9 }}"
    # 审批任务启动后，等待外部系统发布 approval.approved 事件

  - id: load_features_after_approval
    type: task
    taskDefinition:
      ref: "com.company.tasks:sql_load:1.0.0"
    # 订阅外部系统发布的审批事件
    startWhen: "event:approval.approved && {{ approval.result == 'approved' }}"
    inputBindings:
      features: "{{ merge_and_validate_features.merged_features }}"
```

---

### 3. 定时事件（由平台调度器发布）

定时事件由平台的调度器组件发布到事件总线：

```java
@Component
public class CronScheduler {
    private final EventBus eventBus;
    private final ScheduledExecutorService scheduler;

    /**
     * 注册 cron 订阅
     */
    public void registerCronSubscription(String executionId, String cronExpression) {
        ScheduledFuture<?> future = scheduler.schedule(() -> {
            CronEvent event = CronEvent.builder()
                .eventId(UUID.randomUUID().toString())
                .eventType("cron:" + cronExpression)
                .executionId(executionId)
                .timestamp(Instant.now())
                .build();

            eventBus.publish(event);
        }, calculateNextDelay(cronExpression), TimeUnit.MILLISECONDS);

        // 记录调度任务，用于取消
        registerScheduledTask(executionId, cronExpression, future);
    }
}
```

---

### 4. 事件注册与验证

为了支持节点订阅事件，需要在任务定义或节点配置中声明事件：

```yaml
# TaskDefinition 中声明任务会产生哪些自定义事件
TaskDefinition:
  namespace: "com.company.tasks"
  name: "model_inference"
  version: "1.0.0"

  # 声明自定义事件
  outputEvents:
    - name: "batch_ready"
      description: "推理批次准备就绪"
      payload:
        - name: "batch_id"
          type: "string"
        - name: "record_count"
          type: "integer"

    - name: "model_error"
      description: "模型推理错误"
      payload:
        - name: "error_message"
          type: "string"
```

**验证逻辑**：

```java
@Component
public class EventSubscriptionValidator {
    /**
     * 验证节点的 startWhen 引用的事件是否合法
     */
    public void validateEventReferences(PipelineDefinition pipeline, Node node) {
        List<String> eventRefs = parseEventReferences(node.getStartWhen());

        for (String eventRef : eventRefs) {
            // eventRef 格式: "node_id.event_name"
            String[] parts = eventRef.split("\\.");
            String nodeId = parts[0];
            String eventName = parts[1];

            // 检查引用的节点是否存在
            Node referencedNode = pipeline.getNode(nodeId);
            if (referencedNode == null) {
                throw new ValidationException("Referenced node not found: " + nodeId);
            }

            // 检查节点是否声明了该事件
            TaskDefinition taskDef = getTaskDefinition(referencedNode);
            if (!taskDef.hasOutputEvent(eventName)) {
                // 标准事件（started, completed, failed）无需声明
                if (!isStandardEvent(eventName)) {
                    throw new ValidationException(
                        "Event not declared in task definition: " + eventRef
                    );
                }
            }
        }
    }

    private boolean isStandardEvent(String eventName) {
        return List.of("started", "completed", "failed", "stopped", "restarted")
            .contains(eventName);
    }
}
```

---

## 监控和调试

### 事件追踪

```java
@Component
public class EventTracer {
    private final EventStore eventStore;

    @EventListener
    public void traceEvent(DomainEvent event) {
        EventTrace trace = EventTrace.builder()
            .eventId(event.getEventId())
            .eventType(event.getEventType())
            .executionId(event.getExecutionId())
            .timestamp(event.getTimestamp())
            .payload(event.getPayload())
            .build();

        eventStore.append(trace);
    }
}

// 查询 API
@RestController
@RequestMapping("/api/v1/executions/{executionId}/events")
public class EventQueryController {
    private final EventStore eventStore;

    @GetMapping
    public List<EventTrace> getEvents(@PathVariable String executionId) {
        return eventStore.queryByExecution(executionId);
    }
}
```

### 订阅监控

```java
@Component
public class SubscriptionMonitor {
    private final EventManager eventManager;

    @Scheduled(fixedRate = 60000)  // 每分钟检查
    public void monitorSubscriptions() {
        Map<String, Integer> subscriptionCounts = eventManager.getSubscriptionCounts();

        // 报警：订阅数异常增长
        if (subscriptionCounts.values().stream().anyMatch(count -> count > 10000)) {
            alertService.alert("Subscription count exceeded threshold");
        }
    }
}
```

---

## 总结

### 推荐方案总结表

| 阶段 | 方案 | 适用场景 | 优先级 |
|------|------|---------|-------|
| **MVP（初期）** | **Guava EventBus / Spring Event** | 单实例部署、内部事件为主 | ⭐⭐⭐⭐⭐ |
| **成长期** | 内存 + Redis Stream | 多实例部署、需要外部集成 | ⭐⭐⭐⭐ |
| **成熟期** | 内存 + Kafka | 大规模集群、事件溯源 | ⭐⭐⭐ |

### 关键决策

1. **初期使用内存事件总线（Guava EventBus 或 Spring Event）**
   - 快速实现 MVP
   - 满足当前需求
   - 降低运维成本

2. **设计抽象接口，保持扩展性**
   - `EventBus` 接口抽象
   - 支持后续透明升级
   - 业务代码无感知

3. **按需演进，避免过度设计**
   - 不提前引入 Kafka
   - 根据实际负载决定升级时机
   - 渐进式架构演进

4. **外部事件通过适配器集成**
   - Webhook、Kafka 消息转换为内部事件
   - 统一事件模型
   - 解耦外部依赖

### 实施路线图

#### Phase 1（当前）：内存事件总线
- [ ] 实现 `EventBus` 接口
- [ ] 基于 Guava EventBus 的适配器
- [ ] `EventManager` 实现（订阅管理、条件评估）
- [ ] 单元测试 + 集成测试

#### Phase 2（未来）：事件发布接口
- [ ] TaskExecutionContext SDK 实现
- [ ] REST API 发布事件接口
- [ ] 定时调度器集成（Quartz）
- [ ] 事件注册与验证机制

#### Phase 3（长期）：分布式事件总线
- [ ] Redis Stream 适配器
- [ ] 混合路由策略
- [ ] 事件持久化和回溯
- [ ] 监控和追踪系统

---

## 参考资料

- [Guava EventBus Documentation](https://github.com/google/guava/wiki/EventBusExplained)
- [Spring Event Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events)
- [ADR-001: 事件驱动执行模型](./ADRs/001-event-driven-execution.md)
- [场景5执行时序图](../需求分析/场景5执行时序图.md)
- [Event 领域模型设计](../领域模型设计/Event.md)
